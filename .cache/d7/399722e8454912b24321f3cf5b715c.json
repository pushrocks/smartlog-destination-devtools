{"id":"node_modules/@pushrocks/tapbundle/dist/tapbundle.classes.taptools.js","dependencies":[{"name":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/ts/tapbundle.classes.taptools.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/package.json","includedInParent":true,"mtime":1542067438335},{"name":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/package.json","includedInParent":true,"mtime":1542063791802},{"name":"./tapbundle.plugins","loc":{"line":11,"column":24},"parent":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/dist/tapbundle.classes.taptools.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/dist/tapbundle.plugins.js"}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst plugins = require(\"./tapbundle.plugins\");\nclass TapTools {\n    constructor(TapTestArg) {\n        this._tapTest = TapTestArg;\n    }\n    /**\n     * allow failure\n     */\n    allowFailure() {\n        this._tapTest.failureAllowed = true;\n    }\n    /**\n     * async/await delay method\n     */\n    delayFor(timeMilliArg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield plugins.smartdelay.delayFor(timeMilliArg);\n        });\n    }\n    delayForRandom(timeMilliMinArg, timeMilliMaxArg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield plugins.smartdelay.delayForRandom(timeMilliMinArg, timeMilliMaxArg);\n        });\n    }\n    timeout(timeMilliArg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let timeout = new plugins.smartdelay.Timeout(timeMilliArg);\n            timeout.makeUnrefed();\n            yield timeout.promise;\n            if (this._tapTest.status === 'pending') {\n                this._tapTest.status = 'timeout';\n            }\n        });\n    }\n    checkIterationLeak(iterationfuncArg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield plugins.leakage.iterate.async(iterationfuncArg);\n        });\n    }\n    returnError(throwingFuncArg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let funcErr;\n            try {\n                yield throwingFuncArg();\n            }\n            catch (err) {\n                funcErr = err;\n            }\n            return funcErr;\n        });\n    }\n}\nexports.TapTools = TapTools;\n","map":{"version":3,"file":"tapbundle.classes.taptools.js","sourceRoot":"","sources":["../ts/tapbundle.classes.taptools.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,+CAA+C;AAO/C,MAAa,QAAQ;IAMnB,YAAY,UAAU;QACpB,IAAI,CAAC,QAAQ,GAAG,UAAU,CAAC;IAC7B,CAAC;IAED;;OAEG;IACH,YAAY;QACV,IAAI,CAAC,QAAQ,CAAC,cAAc,GAAG,IAAI,CAAC;IACtC,CAAC;IAED;;OAEG;IACG,QAAQ,CAAC,YAAY;;YACzB,MAAM,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAClD,CAAC;KAAA;IAEK,cAAc,CAAC,eAAe,EAAE,eAAe;;YACnD,MAAM,OAAO,CAAC,UAAU,CAAC,cAAc,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;QAC5E,CAAC;KAAA;IAEK,OAAO,CAAC,YAAoB;;YAChC,IAAI,OAAO,GAAG,IAAI,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;YAC3D,OAAO,CAAC,WAAW,EAAE,CAAC;YACtB,MAAM,OAAO,CAAC,OAAO,CAAC;YACtB,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,SAAS,EAAE;gBACtC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,SAAS,CAAC;aAClC;QACH,CAAC;KAAA;IAEK,kBAAkB,CAAC,gBAA8B;;YACrD,MAAM,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;QACxD,CAAC;KAAA;IAEK,WAAW,CAAC,eAA6B;;YAC7C,IAAI,OAAc,CAAC;YACnB,IAAI;gBACF,MAAM,eAAe,EAAE,CAAC;aACzB;YAAC,OAAO,GAAG,EAAE;gBACZ,OAAO,GAAG,GAAG,CAAC;aACf;YACD,OAAO,OAAO,CAAC;QACjB,CAAC;KAAA;CACF;AAlDD,4BAkDC","sourcesContent":["import * as plugins from './tapbundle.plugins';\nimport { TapTest } from './tapbundle.classes.taptest';\n\nexport interface IPromiseFunc {\n  (): Promise<any>;\n}\n\nexport class TapTools {\n  /**\n   * the referenced TapTest\n   */\n  private _tapTest: TapTest;\n\n  constructor(TapTestArg) {\n    this._tapTest = TapTestArg;\n  }\n\n  /**\n   * allow failure\n   */\n  allowFailure() {\n    this._tapTest.failureAllowed = true;\n  }\n\n  /**\n   * async/await delay method\n   */\n  async delayFor(timeMilliArg) {\n    await plugins.smartdelay.delayFor(timeMilliArg);\n  }\n\n  async delayForRandom(timeMilliMinArg, timeMilliMaxArg) {\n    await plugins.smartdelay.delayForRandom(timeMilliMinArg, timeMilliMaxArg);\n  }\n\n  async timeout(timeMilliArg: number) {\n    let timeout = new plugins.smartdelay.Timeout(timeMilliArg);\n    timeout.makeUnrefed();\n    await timeout.promise;\n    if (this._tapTest.status === 'pending') {\n      this._tapTest.status = 'timeout';\n    }\n  }\n\n  async checkIterationLeak(iterationfuncArg: IPromiseFunc) {\n    await plugins.leakage.iterate.async(iterationfuncArg);\n  }\n\n  async returnError(throwingFuncArg: IPromiseFunc) {\n    let funcErr: Error;\n    try {\n      await throwingFuncArg();\n    } catch (err) {\n      funcErr = err;\n    }\n    return funcErr;\n  }\n}\n"]}},"hash":"da259f38cc3e1de64c5c587328e4d64a","cacheData":{"env":{}}}