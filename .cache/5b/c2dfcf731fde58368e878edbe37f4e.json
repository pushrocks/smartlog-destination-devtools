{"id":"node_modules/@pushrocks/tapbundle/dist/tapbundle.classes.taptest.js","dependencies":[{"name":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/ts/tapbundle.classes.taptest.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/package.json","includedInParent":true,"mtime":1542067438335},{"name":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/package.json","includedInParent":true,"mtime":1542063791802},{"name":"./tapbundle.plugins","loc":{"line":11,"column":24},"parent":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/dist/tapbundle.classes.taptest.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/dist/tapbundle.plugins.js"},{"name":"./tapbundle.classes.taptools","loc":{"line":12,"column":45},"parent":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/dist/tapbundle.classes.taptest.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/dist/tapbundle.classes.taptools.js"},{"name":"@pushrocks/early","loc":{"line":14,"column":24},"parent":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/tapbundle/dist/tapbundle.classes.taptest.js","resolved":"/Users/philkunz/gitlab/pushrocks_meta/smartlog-destination-devtools/node_modules/@pushrocks/early/dist/index.js"}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst plugins = require(\"./tapbundle.plugins\");\nconst tapbundle_classes_taptools_1 = require(\"./tapbundle.classes.taptools\");\n// imported interfaces\nconst early_1 = require(\"@pushrocks/early\");\nclass TapTest {\n    /**\n     * constructor\n     */\n    constructor(optionsArg) {\n        this.testDeferred = plugins.smartpromise.defer();\n        this.testPromise = this.testDeferred.promise;\n        this.description = optionsArg.description;\n        this.hrtMeasurement = new early_1.HrtMeasurement();\n        this.parallel = optionsArg.parallel;\n        this.status = 'pending';\n        this.tapTools = new tapbundle_classes_taptools_1.TapTools(this);\n        this.testFunction = optionsArg.testFunction;\n    }\n    /**\n     * run the test\n     */\n    run(testKeyArg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.hrtMeasurement.start();\n            this.testKey = testKeyArg;\n            let testNumber = testKeyArg + 1;\n            try {\n                yield this.testFunction(this.tapTools);\n                if (this.status === 'timeout') {\n                    throw new Error('Test succeeded, but timed out...');\n                }\n                this.hrtMeasurement.stop();\n                console.log(`ok ${testNumber} - ${this.description} # time=${this.hrtMeasurement.milliSeconds}ms`);\n                this.status = 'success';\n                this.testDeferred.resolve(this);\n            }\n            catch (err) {\n                this.hrtMeasurement.stop();\n                console.log(`not ok ${testNumber} - ${this.description} # time=${this.hrtMeasurement.milliSeconds}ms`);\n                this.testDeferred.resolve(this);\n                // if the test has already succeeded before\n                if (this.status === 'success') {\n                    this.status = 'errorAfterSuccess';\n                    console.log('!!! ALERT !!!: weird behaviour, since test has been already successfull');\n                }\n                else {\n                    this.status = 'error';\n                }\n                // if the test is allowed to fail\n                if (this.failureAllowed) {\n                    console.log(`please note: failure allowed!`);\n                }\n                console.log(err);\n            }\n        });\n    }\n}\nexports.TapTest = TapTest;\n","map":{"version":3,"file":"tapbundle.classes.taptest.js","sourceRoot":"","sources":["../ts/tapbundle.classes.taptest.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,+CAA+C;AAE/C,6EAAwD;AAExD,sBAAsB;AACtB,4CAAkD;AAUlD,MAAa,OAAO;IAWlB;;OAEG;IACH,YAAY,UAAmF;QAL/F,iBAAY,GAAsB,OAAO,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;QAC/D,gBAAW,GAAqB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC;QAKxD,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC,WAAW,CAAC;QAC1C,IAAI,CAAC,cAAc,GAAG,IAAI,sBAAc,EAAE,CAAC;QAC3C,IAAI,CAAC,QAAQ,GAAG,UAAU,CAAC,QAAQ,CAAC;QACpC,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,IAAI,qCAAQ,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,YAAY,GAAG,UAAU,CAAC,YAAY,CAAC;IAC9C,CAAC;IAED;;OAEG;IACG,GAAG,CAAC,UAAkB;;YAC1B,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;YAC5B,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;YAC1B,IAAI,UAAU,GAAG,UAAU,GAAG,CAAC,CAAC;YAChC,IAAI;gBACF,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACvC,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE;oBAC7B,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;iBACrD;gBACD,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;gBAC3B,OAAO,CAAC,GAAG,CACT,MAAM,UAAU,MAAM,IAAI,CAAC,WAAW,WAAW,IAAI,CAAC,cAAc,CAAC,YAAY,IAAI,CACtF,CAAC;gBACF,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;gBACxB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;aACjC;YAAC,OAAO,GAAG,EAAE;gBACZ,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;gBAC3B,OAAO,CAAC,GAAG,CACT,UAAU,UAAU,MAAM,IAAI,CAAC,WAAW,WAAW,IAAI,CAAC,cAAc,CAAC,YAAY,IAAI,CAC1F,CAAC;gBACF,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBAEhC,2CAA2C;gBAC3C,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE;oBAC7B,IAAI,CAAC,MAAM,GAAG,mBAAmB,CAAC;oBAClC,OAAO,CAAC,GAAG,CAAC,yEAAyE,CAAC,CAAC;iBACxF;qBAAM;oBACL,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC;iBACvB;gBAED,iCAAiC;gBACjC,IAAI,IAAI,CAAC,cAAc,EAAE;oBACvB,OAAO,CAAC,GAAG,CAAC,+BAA+B,CAAC,CAAC;iBAC9C;gBACD,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;aAClB;QACH,CAAC;KAAA;CACF;AA/DD,0BA+DC","sourcesContent":["import * as plugins from './tapbundle.plugins';\nimport { tapCreator } from './tapbundle.tapcreator';\nimport { TapTools } from './tapbundle.classes.taptools';\n\n// imported interfaces\nimport { HrtMeasurement } from '@pushrocks/early';\nimport { Deferred } from '@pushrocks/smartpromise';\n\n// interfaces\nexport type TTestStatus = 'success' | 'error' | 'pending' | 'errorAfterSuccess' | 'timeout';\n\nexport interface ITestFunction {\n  (tapTools?: TapTools): Promise<any>;\n}\n\nexport class TapTest {\n  description: string;\n  failureAllowed: boolean;\n  hrtMeasurement: HrtMeasurement;\n  parallel: boolean;\n  status: TTestStatus;\n  tapTools: TapTools;\n  testFunction: ITestFunction;\n  testKey: number; // the testKey the position in the test qeue. Set upon calling .run()\n  testDeferred: Deferred<TapTest> = plugins.smartpromise.defer();\n  testPromise: Promise<TapTest> = this.testDeferred.promise;\n  /**\n   * constructor\n   */\n  constructor(optionsArg: { description: string; testFunction: ITestFunction; parallel: boolean }) {\n    this.description = optionsArg.description;\n    this.hrtMeasurement = new HrtMeasurement();\n    this.parallel = optionsArg.parallel;\n    this.status = 'pending';\n    this.tapTools = new TapTools(this);\n    this.testFunction = optionsArg.testFunction;\n  }\n\n  /**\n   * run the test\n   */\n  async run(testKeyArg: number) {\n    this.hrtMeasurement.start();\n    this.testKey = testKeyArg;\n    let testNumber = testKeyArg + 1;\n    try {\n      await this.testFunction(this.tapTools);\n      if (this.status === 'timeout') {\n        throw new Error('Test succeeded, but timed out...');\n      }\n      this.hrtMeasurement.stop();\n      console.log(\n        `ok ${testNumber} - ${this.description} # time=${this.hrtMeasurement.milliSeconds}ms`\n      );\n      this.status = 'success';\n      this.testDeferred.resolve(this);\n    } catch (err) {\n      this.hrtMeasurement.stop();\n      console.log(\n        `not ok ${testNumber} - ${this.description} # time=${this.hrtMeasurement.milliSeconds}ms`\n      );\n      this.testDeferred.resolve(this);\n\n      // if the test has already succeeded before\n      if (this.status === 'success') {\n        this.status = 'errorAfterSuccess';\n        console.log('!!! ALERT !!!: weird behaviour, since test has been already successfull');\n      } else {\n        this.status = 'error';\n      }\n\n      // if the test is allowed to fail\n      if (this.failureAllowed) {\n        console.log(`please note: failure allowed!`);\n      }\n      console.log(err);\n    }\n  }\n}\n"]}},"hash":"c1cff0c9d16f9dec4529c7cba9b54143","cacheData":{"env":{}}}